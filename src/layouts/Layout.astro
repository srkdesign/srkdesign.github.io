---
import i18n from "i18next";
import { SITE_TITLE } from "../consts";

import BaseHead from "../components/BaseHead.astro";
import Header from "../components/Header";
import Footer from "../components/Footer";

const { title, description, locale } = Astro.props;
const isBlogPage = Astro.url.pathname.includes("blog");
const postImage = `/images${Astro.url.pathname}hero.png`;
---

<html lang={locale || i18n.language} class="text-base">
  <head>
    <BaseHead
      title={title || SITE_TITLE}
      description={description || i18n.t("site.description")}
      image={isBlogPage && Astro.url.pathname != "/blog/"
        ? postImage
        : `/image.png`}
    />
  </head>
  <body class="text-zinc-50 bg-zinc-950">
    <!-- Loader -->
    <div id="page-loader">
      <div class="loader-content"></div>
    </div>
    <!-- Content -->
    <div id="page">
      <Header client:only="react" />
      <main class="pt-28">
        <slot />
      </main>
      <Footer client:only="react" />
      <!-- {!isBlogPage ? <DiscussProject client:only="react" /> : ""} -->
    </div>
  </body>
</html>

<script>
  const loader = document.querySelector("#page-loader") as HTMLElement;
  const page = document.querySelector("#page");

  // Wait for assets to load first
  async function waitForPageLoad() {
    await new Promise((resolve) => {
      if (document.readyState === "complete") {
        resolve(null);
      } else {
        window.addEventListener("load", resolve);
      }
    });

    console.log("page loaded");

    await document.fonts.ready;

    console.log("fonts loaded");

    await new Promise((resolve) => requestAnimationFrame(resolve));

    console.log("react components loaded");

    await new Promise((resolve) => {
      function checkImages() {
        const images = Array.from(document.images).filter(
          (img) => img.loading !== "lazy",
        );
        if (images.length > 0 && images.every((img) => img.complete)) {
          resolve(null);
        } else {
          requestAnimationFrame(checkImages);
        }
      }
      checkImages();
    });

    console.log("images loaded");

    loader?.classList.add("transitioned");
  }

  waitForPageLoad();

  // Handle links on page
  document.addEventListener("click", (e) => {
    const link = (e.target as HTMLElement).closest("a");
    if (!link?.href || link.target) return;
    const url = new URL(link.href);

    // If anchor link don't show transition
    if (url.pathname === location.pathname && url.hash) return;

    // If external link don't show transition
    if (url.origin !== location.origin) return;

    e.preventDefault();
    page?.classList.add("faded");
    setTimeout(() => {
      loader?.classList.remove("shown");
      // document.getElementById("overlay")?.classList.remove("hide");
      setTimeout(() => {
        window.location.href = link.href;
      }, 300);
    }, 300);
  });

  // Handle back and forward browser button navigation
  window.addEventListener("pageshow", (e) => {
    if (e.persisted) {
      page?.classList.remove("faded");
      loader?.classList.add("transitioned");
    }
  });

  function waitForRevealImages() {
    const images = document.querySelectorAll(".reveal-image");
    if (images.length) {
      revealImg(images);
    } else {
      // retry next frame
      requestAnimationFrame(waitForRevealImages);
    }
  }

  // Observe loader transition first
  const loaderObserver = new MutationObserver(() => {
    if (loader?.classList.contains("transitioned")) {
      waitForRevealImages(); // wait for images to mount
      loaderObserver.disconnect();
    }
  });

  loaderObserver.observe(loader, {
    attributes: true,
    attributeFilter: ["class"],
  });

  function revealImg(images: NodeListOf<Element> | Element[]) {
    const observer = new IntersectionObserver(
      (entries, obs) => {
        entries.forEach((entry) => {
          if (!entry.isIntersecting) return;
          entry.target.classList.add("visible");
          obs.unobserve(entry.target);
        });
      },
      { threshold: 0.2 },
    );

    images.forEach((el) => observer.observe(el));
  }
</script>
